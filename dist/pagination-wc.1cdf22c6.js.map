{"version":3,"sources":["../src/util.js","../src/constants.js","../src/options.js","../src/create-element.js","../src/component.js","../src/create-context.js","../src/diff/children.js","../src/diff/props.js","../src/diff/index.js","../src/render.js","../src/clone-element.js","../src/diff/catch-error.js","../src/index.js","../node_modules/classnames/index.js","pagination.tsx","pagination-wc.tsx"],"names":["slice","options","vnodeId","isValidElement","rerenderQueue","defer","prevDebounce","i","EMPTY_OBJ","EMPTY_ARR","IS_NON_DIMENSIONAL","assign","obj","props","removeNode","node","parentNode","removeChild","createElement","type","children","key","ref","normalizedProps","arguments","length","call","defaultProps","createVNode","original","vnode","undefined","constructor","createRef","current","Fragment","Component","context","getDomSibling","childIndex","indexOf","sibling","updateParentDomPointers","child","base","enqueueRender","c","push","process","debounceRendering","queue","sort","a","b","some","component","commitQueue","oldVNode","oldDom","parentDom","diff","ownerSVGElement","commitRoot","diffChildren","renderResult","newParentVNode","oldParentVNode","globalContext","isSvg","excessDomChildren","isHydrating","j","childVNode","newDom","firstChildDom","refs","oldChildren","oldChildrenLength","Array","isArray","reorderChildren","placeChild","unmount","applyRef","tmp","toChildArray","out","nextDom","sibDom","outer","appendChild","nextSibling","insertBefore","diffProps","dom","newProps","oldProps","hydrate","setProperty","setStyle","style","value","test","name","oldValue","useCapture","o","cssText","replace","toLowerCase","_listeners","addEventListener","eventProxyCapture","eventProxy","removeEventListener","e","setAttribute","removeAttribute","event","newVNode","isNew","oldState","snapshot","clearProcessingException","provider","componentContext","newType","contextType","prototype","render","doRender","sub","state","getDerivedStateFromProps","componentWillMount","componentDidMount","componentWillReceiveProps","shouldComponentUpdate","forEach","componentWillUpdate","componentDidUpdate","getChildContext","getSnapshotBeforeUpdate","diffElementNodes","diffed","root","cb","oldHtml","newHtml","nodeType","localName","document","createTextNode","createElementNS","is","data","childNodes","dangerouslySetInnerHTML","attributes","innerHTML","checked","parentVNode","skipRemove","r","componentWillUnmount","this","replaceNode","firstChild","cloneElement","createContext","defaultValue","contextId","Consumer","contextValue","Provider","subs","ctx","_props","old","splice","error","ctor","handled","getDerivedStateFromError","setState","componentDidCatch","update","callback","s","forceUpdate","Promise","then","bind","resolve","setTimeout","__source","__self","PreactElement","ContextProvider","rest","connectedCallback","CustomEvent","detail","bubbles","cancelable","dispatchEvent","_vdom","h","toVdom","element","nodeName","cn","toCamelCase","slot","Slot","wrappedChildren","_vdomComponent","hasAttribute","_root","str","_","toUpperCase","attributeChangedCallback","newValue","disconnectedCallback","_this","_listener","stopPropagation","tagName","propNames","inst","Reflect","construct","HTMLElement","shadow","attachShadow","mode","Object","create","observedAttributes","keys","propTypes","defineProperty","get","set","v","customElements","define","displayName","f","currentIndex","currentComponent","prevRaf","currentHook","afterPaintEffects","oldBeforeDiff","oldBeforeRender","oldAfterDiff","oldCommit","oldBeforeUnmount","getHookState","index","hooks","useState","initialState","useReducer","invokeOrReturn","reducer","init","hookState","_reducer","action","nextValue","useEffect","args","argsChanged","useLayoutEffect","useRef","initialValue","useMemo","useImperativeHandle","createHandle","concat","factory","useCallback","useContext","useDebugValue","formatter","useErrorBoundary","errState","err","flushAfterPaintEffects","pop","invokeCleanup","invokeEffect","requestAnimationFrame","raf","done","clearTimeout","timeout","HAS_RAF","cancelAnimationFrame","filter","hasErrored","hook","comp","cleanup","oldArgs","newArgs","arg"],"mappings":"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","file":"pagination-wc.1cdf22c6.js","sourceRoot":"../src","sourcesContent":["import { EMPTY_ARR } from \"./constants\";\r\n\r\n/**\r\n * Assign properties from `props` to `obj`\r\n * @template O, P The obj and props types\r\n * @param {O} obj The object to copy properties to\r\n * @param {P} props The object to copy properties from\r\n * @returns {O & P}\r\n */\r\nexport function assign(obj, props) {\r\n\t// @ts-ignore We change the type of `obj` to be `O & P`\r\n\tfor (let i in props) obj[i] = props[i];\r\n\treturn /** @type {O & P} */ (obj);\r\n}\r\n\r\n/**\r\n * Remove a child node from its parent if attached. This is a workaround for\r\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\r\n * is smaller than including a dedicated polyfill.\r\n * @param {Node} node The node to remove\r\n */\r\nexport function removeNode(node) {\r\n\tlet parentNode = node.parentNode;\r\n\tif (parentNode) parentNode.removeChild(node);\r\n}\r\n\r\nexport const slice = EMPTY_ARR.slice;\r\n","export const EMPTY_OBJ = {};\r\nexport const EMPTY_ARR = [];\r\nexport const IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\r\n","import { _catchError } from './diff/catch-error';\r\n\r\n/**\r\n * The `option` object can potentially contain callback functions\r\n * that are called during various stages of our renderer. This is the\r\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\r\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\r\n * for a full list of available option hooks (most editors/IDEs allow you to\r\n * ctrl+click or cmd+click on mac the type definition below).\r\n * @type {import('./internal').Options}\r\n */\r\nconst options = {\r\n\t_catchError\r\n};\r\n\r\nexport default options;\r\n","import { slice } from './util';\r\nimport options from './options';\r\n\r\nlet vnodeId = 0;\r\n\r\n/**\r\n * Create an virtual node (used for JSX)\r\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\r\n * constructor for this virtual node\r\n * @param {object | null | undefined} [props] The properties of the virtual node\r\n * @param {Array<import('.').ComponentChildren>} [children] The children of the virtual node\r\n * @returns {import('./internal').VNode}\r\n */\r\nexport function createElement(type, props, children) {\r\n\tlet normalizedProps = {},\r\n\t\tkey,\r\n\t\tref,\r\n\t\ti;\r\n\tfor (i in props) {\r\n\t\tif (i == 'key') key = props[i];\r\n\t\telse if (i == 'ref') ref = props[i];\r\n\t\telse normalizedProps[i] = props[i];\r\n\t}\r\n\r\n\tif (arguments.length > 2) {\r\n\t\tnormalizedProps.children =\r\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\r\n\t}\r\n\r\n\t// If a Component VNode, check for and apply defaultProps\r\n\t// Note: type may be undefined in development, must never error here.\r\n\tif (typeof type == 'function' && type.defaultProps != null) {\r\n\t\tfor (i in type.defaultProps) {\r\n\t\t\tif (normalizedProps[i] === undefined) {\r\n\t\t\t\tnormalizedProps[i] = type.defaultProps[i];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn createVNode(type, normalizedProps, key, ref, null);\r\n}\r\n\r\n/**\r\n * Create a VNode (used internally by Preact)\r\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\r\n * Constructor for this virtual node\r\n * @param {object | string | number | null} props The properties of this virtual node.\r\n * If this virtual node represents a text node, this is the text of the node (string or number).\r\n * @param {string | number | null} key The key for this virtual node, used when\r\n * diffing it against its children\r\n * @param {import('./internal').VNode[\"ref\"]} ref The ref property that will\r\n * receive a reference to its created child\r\n * @returns {import('./internal').VNode}\r\n */\r\nexport function createVNode(type, props, key, ref, original) {\r\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\r\n\t// Do not inline into createElement and coerceToVNode!\r\n\tconst vnode = {\r\n\t\ttype,\r\n\t\tprops,\r\n\t\tkey,\r\n\t\tref,\r\n\t\t_children: null,\r\n\t\t_parent: null,\r\n\t\t_depth: 0,\r\n\t\t_dom: null,\r\n\t\t// _nextDom must be initialized to undefined b/c it will eventually\r\n\t\t// be set to dom.nextSibling which can return `null` and it is important\r\n\t\t// to be able to distinguish between an uninitialized _nextDom and\r\n\t\t// a _nextDom that has been set to `null`\r\n\t\t_nextDom: undefined,\r\n\t\t_component: null,\r\n\t\t_hydrating: null,\r\n\t\tconstructor: undefined,\r\n\t\t_original: original == null ? ++vnodeId : original\r\n\t};\r\n\r\n\t// Only invoke the vnode hook if this was *not* a direct copy:\r\n\tif (original == null && options.vnode != null) options.vnode(vnode);\r\n\r\n\treturn vnode;\r\n}\r\n\r\nexport function createRef() {\r\n\treturn { current: null };\r\n}\r\n\r\nexport function Fragment(props) {\r\n\treturn props.children;\r\n}\r\n\r\n/**\r\n * Check if a the argument is a valid Preact VNode.\r\n * @param {*} vnode\r\n * @returns {vnode is import('./internal').VNode}\r\n */\r\nexport const isValidElement = vnode =>\r\n\tvnode != null && vnode.constructor === undefined;\r\n","import { assign } from './util';\r\nimport { diff, commitRoot } from './diff/index';\r\nimport options from './options';\r\nimport { Fragment } from './create-element';\r\n\r\n/**\r\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\r\n * trigger rendering\r\n * @param {object} props The initial component props\r\n * @param {object} context The initial context from parent components'\r\n * getChildContext\r\n */\r\nexport function Component(props, context) {\r\n\tthis.props = props;\r\n\tthis.context = context;\r\n}\r\n\r\n/**\r\n * Update component state and schedule a re-render.\r\n * @this {import('./internal').Component}\r\n * @param {object | ((s: object, p: object) => object)} update A hash of state\r\n * properties to update with new values or a function that given the current\r\n * state and props returns a new partial state\r\n * @param {() => void} [callback] A function to be called once component state is\r\n * updated\r\n */\r\nComponent.prototype.setState = function(update, callback) {\r\n\t// only clone state when copying to nextState the first time.\r\n\tlet s;\r\n\tif (this._nextState != null && this._nextState !== this.state) {\r\n\t\ts = this._nextState;\r\n\t} else {\r\n\t\ts = this._nextState = assign({}, this.state);\r\n\t}\r\n\r\n\tif (typeof update == 'function') {\r\n\t\t// Some libraries like `immer` mark the current state as readonly,\r\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\r\n\t\tupdate = update(assign({}, s), this.props);\r\n\t}\r\n\r\n\tif (update) {\r\n\t\tassign(s, update);\r\n\t}\r\n\r\n\t// Skip update if updater function returned null\r\n\tif (update == null) return;\r\n\r\n\tif (this._vnode) {\r\n\t\tif (callback) this._renderCallbacks.push(callback);\r\n\t\tenqueueRender(this);\r\n\t}\r\n};\r\n\r\n/**\r\n * Immediately perform a synchronous re-render of the component\r\n * @this {import('./internal').Component}\r\n * @param {() => void} [callback] A function to be called after component is\r\n * re-rendered\r\n */\r\nComponent.prototype.forceUpdate = function(callback) {\r\n\tif (this._vnode) {\r\n\t\t// Set render mode so that we can differentiate where the render request\r\n\t\t// is coming from. We need this because forceUpdate should never call\r\n\t\t// shouldComponentUpdate\r\n\t\tthis._force = true;\r\n\t\tif (callback) this._renderCallbacks.push(callback);\r\n\t\tenqueueRender(this);\r\n\t}\r\n};\r\n\r\n/**\r\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\r\n * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\r\n * @param {object} props Props (eg: JSX attributes) received from parent\r\n * element/component\r\n * @param {object} state The component's current state\r\n * @param {object} context Context object, as returned by the nearest\r\n * ancestor's `getChildContext()`\r\n * @returns {import('./index').ComponentChildren | void}\r\n */\r\nComponent.prototype.render = Fragment;\r\n\r\n/**\r\n * @param {import('./internal').VNode} vnode\r\n * @param {number | null} [childIndex]\r\n */\r\nexport function getDomSibling(vnode, childIndex) {\r\n\tif (childIndex == null) {\r\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\r\n\t\treturn vnode._parent\r\n\t\t\t? getDomSibling(vnode._parent, vnode._parent._children.indexOf(vnode) + 1)\r\n\t\t\t: null;\r\n\t}\r\n\r\n\tlet sibling;\r\n\tfor (; childIndex < vnode._children.length; childIndex++) {\r\n\t\tsibling = vnode._children[childIndex];\r\n\r\n\t\tif (sibling != null && sibling._dom != null) {\r\n\t\t\t// Since updateParentDomPointers keeps _dom pointer correct,\r\n\t\t\t// we can rely on _dom to tell us if this subtree contains a\r\n\t\t\t// rendered DOM node, and what the first rendered DOM node is\r\n\t\t\treturn sibling._dom;\r\n\t\t}\r\n\t}\r\n\r\n\t// If we get here, we have not found a DOM node in this vnode's children.\r\n\t// We must resume from this vnode's sibling (in it's parent _children array)\r\n\t// Only climb up and search the parent if we aren't searching through a DOM\r\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\r\n\t// the search)\r\n\treturn typeof vnode.type == 'function' ? getDomSibling(vnode) : null;\r\n}\r\n\r\n/**\r\n * Trigger in-place re-rendering of a component.\r\n * @param {import('./internal').Component} component The component to rerender\r\n */\r\nfunction renderComponent(component) {\r\n\tlet vnode = component._vnode,\r\n\t\toldDom = vnode._dom,\r\n\t\tparentDom = component._parentDom;\r\n\r\n\tif (parentDom) {\r\n\t\tlet commitQueue = [];\r\n\t\tconst oldVNode = assign({}, vnode);\r\n\t\toldVNode._original = vnode._original + 1;\r\n\r\n\t\tdiff(\r\n\t\t\tparentDom,\r\n\t\t\tvnode,\r\n\t\t\toldVNode,\r\n\t\t\tcomponent._globalContext,\r\n\t\t\tparentDom.ownerSVGElement !== undefined,\r\n\t\t\tvnode._hydrating != null ? [oldDom] : null,\r\n\t\t\tcommitQueue,\r\n\t\t\toldDom == null ? getDomSibling(vnode) : oldDom,\r\n\t\t\tvnode._hydrating\r\n\t\t);\r\n\t\tcommitRoot(commitQueue, vnode);\r\n\r\n\t\tif (vnode._dom != oldDom) {\r\n\t\t\tupdateParentDomPointers(vnode);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * @param {import('./internal').VNode} vnode\r\n */\r\nfunction updateParentDomPointers(vnode) {\r\n\tif ((vnode = vnode._parent) != null && vnode._component != null) {\r\n\t\tvnode._dom = vnode._component.base = null;\r\n\t\tfor (let i = 0; i < vnode._children.length; i++) {\r\n\t\t\tlet child = vnode._children[i];\r\n\t\t\tif (child != null && child._dom != null) {\r\n\t\t\t\tvnode._dom = vnode._component.base = child._dom;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn updateParentDomPointers(vnode);\r\n\t}\r\n}\r\n\r\n/**\r\n * The render queue\r\n * @type {Array<import('./internal').Component>}\r\n */\r\nlet rerenderQueue = [];\r\n\r\n/**\r\n * Asynchronously schedule a callback\r\n * @type {(cb: () => void) => void}\r\n */\r\n/* istanbul ignore next */\r\n// Note the following line isn't tree-shaken by rollup cuz of rollup/rollup#2566\r\nconst defer =\r\n\ttypeof Promise == 'function'\r\n\t\t? Promise.prototype.then.bind(Promise.resolve())\r\n\t\t: setTimeout;\r\n\r\n/*\r\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\r\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\r\n * do, and when their effects will be applied. See the links below for some further reading on designing\r\n * asynchronous APIs.\r\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\r\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\r\n */\r\n\r\nlet prevDebounce;\r\n\r\n/**\r\n * Enqueue a rerender of a component\r\n * @param {import('./internal').Component} c The component to rerender\r\n */\r\nexport function enqueueRender(c) {\r\n\tif (\r\n\t\t(!c._dirty &&\r\n\t\t\t(c._dirty = true) &&\r\n\t\t\trerenderQueue.push(c) &&\r\n\t\t\t!process._rerenderCount++) ||\r\n\t\tprevDebounce !== options.debounceRendering\r\n\t) {\r\n\t\tprevDebounce = options.debounceRendering;\r\n\t\t(prevDebounce || defer)(process);\r\n\t}\r\n}\r\n\r\n/** Flush the render queue by rerendering all queued components */\r\nfunction process() {\r\n\tlet queue;\r\n\twhile ((process._rerenderCount = rerenderQueue.length)) {\r\n\t\tqueue = rerenderQueue.sort((a, b) => a._vnode._depth - b._vnode._depth);\r\n\t\trerenderQueue = [];\r\n\t\t// Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\r\n\t\t// process() calls from getting scheduled while `queue` is still being consumed.\r\n\t\tqueue.some(c => {\r\n\t\t\tif (c._dirty) renderComponent(c);\r\n\t\t});\r\n\t}\r\n}\r\nprocess._rerenderCount = 0;\r\n","import { enqueueRender } from './component';\r\n\r\nexport let i = 0;\r\n\r\nexport function createContext(defaultValue, contextId) {\r\n\tcontextId = '__cC' + i++;\r\n\r\n\tconst context = {\r\n\t\t_id: contextId,\r\n\t\t_defaultValue: defaultValue,\r\n\t\t/** @type {import('./internal').FunctionComponent} */\r\n\t\tConsumer(props, contextValue) {\r\n\t\t\t// return props.children(\r\n\t\t\t// \tcontext[contextId] ? context[contextId].props.value : defaultValue\r\n\t\t\t// );\r\n\t\t\treturn props.children(contextValue);\r\n\t\t},\r\n\t\t/** @type {import('./internal').FunctionComponent} */\r\n\t\tProvider(props) {\r\n\t\t\tif (!this.getChildContext) {\r\n\t\t\t\tlet subs = [];\r\n\t\t\t\tlet ctx = {};\r\n\t\t\t\tctx[contextId] = this;\r\n\r\n\t\t\t\tthis.getChildContext = () => ctx;\r\n\r\n\t\t\t\tthis.shouldComponentUpdate = function(_props) {\r\n\t\t\t\t\tif (this.props.value !== _props.value) {\r\n\t\t\t\t\t\t// I think the forced value propagation here was only needed when `options.debounceRendering` was being bypassed:\r\n\t\t\t\t\t\t// https://github.com/preactjs/preact/commit/4d339fb803bea09e9f198abf38ca1bf8ea4b7771#diff-54682ce380935a717e41b8bfc54737f6R358\r\n\t\t\t\t\t\t// In those cases though, even with the value corrected, we're double-rendering all nodes.\r\n\t\t\t\t\t\t// It might be better to just tell folks not to use force-sync mode.\r\n\t\t\t\t\t\t// Currently, using `useContext()` in a class component will overwrite its `this.context` value.\r\n\t\t\t\t\t\t// subs.some(c => {\r\n\t\t\t\t\t\t// \tc.context = _props.value;\r\n\t\t\t\t\t\t// \tenqueueRender(c);\r\n\t\t\t\t\t\t// });\r\n\r\n\t\t\t\t\t\t// subs.some(c => {\r\n\t\t\t\t\t\t// \tc.context[contextId] = _props.value;\r\n\t\t\t\t\t\t// \tenqueueRender(c);\r\n\t\t\t\t\t\t// });\r\n\t\t\t\t\t\tsubs.some(enqueueRender);\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\r\n\t\t\t\tthis.sub = c => {\r\n\t\t\t\t\tsubs.push(c);\r\n\t\t\t\t\tlet old = c.componentWillUnmount;\r\n\t\t\t\t\tc.componentWillUnmount = () => {\r\n\t\t\t\t\t\tsubs.splice(subs.indexOf(c), 1);\r\n\t\t\t\t\t\tif (old) old.call(c);\r\n\t\t\t\t\t};\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\treturn props.children;\r\n\t\t}\r\n\t};\r\n\r\n\t// Devtools needs access to the context object when it\r\n\t// encounters a Provider. This is necessary to support\r\n\t// setting `displayName` on the context object instead\r\n\t// of on the component itself. See:\r\n\t// https://reactjs.org/docs/context.html#contextdisplayname\r\n\r\n\treturn (context.Provider._contextRef = context.Consumer.contextType = context);\r\n}\r\n","import { diff, unmount, applyRef } from './index';\r\nimport { createVNode, Fragment } from '../create-element';\r\nimport { EMPTY_OBJ, EMPTY_ARR } from '../constants';\r\nimport { getDomSibling } from '../component';\r\n\r\n/**\r\n * Diff the children of a virtual node\r\n * @param {import('../internal').PreactElement} parentDom The DOM element whose\r\n * children are being diffed\r\n * @param {import('../internal').ComponentChildren[]} renderResult\r\n * @param {import('../internal').VNode} newParentVNode The new virtual\r\n * node whose children should be diff'ed against oldParentVNode\r\n * @param {import('../internal').VNode} oldParentVNode The old virtual\r\n * node whose children should be diff'ed against newParentVNode\r\n * @param {object} globalContext The current context object - modified by getChildContext\r\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\r\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\r\n * @param {Array<import('../internal').Component>} commitQueue List of components\r\n * which have callbacks to invoke in commitRoot\r\n * @param {import('../internal').PreactElement} oldDom The current attached DOM\r\n * element any new dom elements should be placed around. Likely `null` on first\r\n * render (except when hydrating). Can be a sibling DOM element when diffing\r\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\r\n * @param {boolean} isHydrating Whether or not we are in hydration\r\n */\r\nexport function diffChildren(\r\n\tparentDom,\r\n\trenderResult,\r\n\tnewParentVNode,\r\n\toldParentVNode,\r\n\tglobalContext,\r\n\tisSvg,\r\n\texcessDomChildren,\r\n\tcommitQueue,\r\n\toldDom,\r\n\tisHydrating\r\n) {\r\n\tlet i, j, oldVNode, childVNode, newDom, firstChildDom, refs;\r\n\r\n\t// This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\r\n\t// as EMPTY_OBJ._children should be `undefined`.\r\n\tlet oldChildren = (oldParentVNode && oldParentVNode._children) || EMPTY_ARR;\r\n\r\n\tlet oldChildrenLength = oldChildren.length;\r\n\r\n\tnewParentVNode._children = [];\r\n\tfor (i = 0; i < renderResult.length; i++) {\r\n\t\tchildVNode = renderResult[i];\r\n\r\n\t\tif (childVNode == null || typeof childVNode == 'boolean') {\r\n\t\t\tchildVNode = newParentVNode._children[i] = null;\r\n\t\t}\r\n\t\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\r\n\t\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\r\n\t\t// it's own DOM & etc. pointers\r\n\t\telse if (\r\n\t\t\ttypeof childVNode == 'string' ||\r\n\t\t\ttypeof childVNode == 'number' ||\r\n\t\t\t// eslint-disable-next-line valid-typeof\r\n\t\t\ttypeof childVNode == 'bigint'\r\n\t\t) {\r\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\r\n\t\t\t\tnull,\r\n\t\t\t\tchildVNode,\r\n\t\t\t\tnull,\r\n\t\t\t\tnull,\r\n\t\t\t\tchildVNode\r\n\t\t\t);\r\n\t\t} else if (Array.isArray(childVNode)) {\r\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\r\n\t\t\t\tFragment,\r\n\t\t\t\t{ children: childVNode },\r\n\t\t\t\tnull,\r\n\t\t\t\tnull,\r\n\t\t\t\tnull\r\n\t\t\t);\r\n\t\t} else if (childVNode._depth > 0) {\r\n\t\t\t// VNode is already in use, clone it. This can happen in the following\r\n\t\t\t// scenario:\r\n\t\t\t//   const reuse = <div />\r\n\t\t\t//   <div>{reuse}<span />{reuse}</div>\r\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\r\n\t\t\t\tchildVNode.type,\r\n\t\t\t\tchildVNode.props,\r\n\t\t\t\tchildVNode.key,\r\n\t\t\t\tnull,\r\n\t\t\t\tchildVNode._original\r\n\t\t\t);\r\n\t\t} else {\r\n\t\t\tchildVNode = newParentVNode._children[i] = childVNode;\r\n\t\t}\r\n\r\n\t\t// Terser removes the `continue` here and wraps the loop body\r\n\t\t// in a `if (childVNode) { ... } condition\r\n\t\tif (childVNode == null) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tchildVNode._parent = newParentVNode;\r\n\t\tchildVNode._depth = newParentVNode._depth + 1;\r\n\r\n\t\t// Check if we find a corresponding element in oldChildren.\r\n\t\t// If found, delete the array item by setting to `undefined`.\r\n\t\t// We use `undefined`, as `null` is reserved for empty placeholders\r\n\t\t// (holes).\r\n\t\toldVNode = oldChildren[i];\r\n\r\n\t\tif (\r\n\t\t\toldVNode === null ||\r\n\t\t\t(oldVNode &&\r\n\t\t\t\tchildVNode.key == oldVNode.key &&\r\n\t\t\t\tchildVNode.type === oldVNode.type)\r\n\t\t) {\r\n\t\t\toldChildren[i] = undefined;\r\n\t\t} else {\r\n\t\t\t// Either oldVNode === undefined or oldChildrenLength > 0,\r\n\t\t\t// so after this loop oldVNode == null or oldVNode is a valid value.\r\n\t\t\tfor (j = 0; j < oldChildrenLength; j++) {\r\n\t\t\t\toldVNode = oldChildren[j];\r\n\t\t\t\t// If childVNode is unkeyed, we only match similarly unkeyed nodes, otherwise we match by key.\r\n\t\t\t\t// We always match by type (in either case).\r\n\t\t\t\tif (\r\n\t\t\t\t\toldVNode &&\r\n\t\t\t\t\tchildVNode.key == oldVNode.key &&\r\n\t\t\t\t\tchildVNode.type === oldVNode.type\r\n\t\t\t\t) {\r\n\t\t\t\t\toldChildren[j] = undefined;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\toldVNode = null;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\toldVNode = oldVNode || EMPTY_OBJ;\r\n\r\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\r\n\t\tdiff(\r\n\t\t\tparentDom,\r\n\t\t\tchildVNode,\r\n\t\t\toldVNode,\r\n\t\t\tglobalContext,\r\n\t\t\tisSvg,\r\n\t\t\texcessDomChildren,\r\n\t\t\tcommitQueue,\r\n\t\t\toldDom,\r\n\t\t\tisHydrating\r\n\t\t);\r\n\r\n\t\tnewDom = childVNode._dom;\r\n\r\n\t\tif ((j = childVNode.ref) && oldVNode.ref != j) {\r\n\t\t\tif (!refs) refs = [];\r\n\t\t\tif (oldVNode.ref) refs.push(oldVNode.ref, null, childVNode);\r\n\t\t\trefs.push(j, childVNode._component || newDom, childVNode);\r\n\t\t}\r\n\r\n\t\tif (newDom != null) {\r\n\t\t\tif (firstChildDom == null) {\r\n\t\t\t\tfirstChildDom = newDom;\r\n\t\t\t}\r\n\r\n\t\t\tif (\r\n\t\t\t\ttypeof childVNode.type == 'function' &&\r\n\t\t\t\tchildVNode._children === oldVNode._children\r\n\t\t\t) {\r\n\t\t\t\tchildVNode._nextDom = oldDom = reorderChildren(\r\n\t\t\t\t\tchildVNode,\r\n\t\t\t\t\toldDom,\r\n\t\t\t\t\tparentDom\r\n\t\t\t\t);\r\n\t\t\t} else {\r\n\t\t\t\toldDom = placeChild(\r\n\t\t\t\t\tparentDom,\r\n\t\t\t\t\tchildVNode,\r\n\t\t\t\t\toldVNode,\r\n\t\t\t\t\toldChildren,\r\n\t\t\t\t\tnewDom,\r\n\t\t\t\t\toldDom\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\tif (typeof newParentVNode.type == 'function') {\r\n\t\t\t\t// Because the newParentVNode is Fragment-like, we need to set it's\r\n\t\t\t\t// _nextDom property to the nextSibling of its last child DOM node.\r\n\t\t\t\t//\r\n\t\t\t\t// `oldDom` contains the correct value here because if the last child\r\n\t\t\t\t// is a Fragment-like, then oldDom has already been set to that child's _nextDom.\r\n\t\t\t\t// If the last child is a DOM VNode, then oldDom will be set to that DOM\r\n\t\t\t\t// node's nextSibling.\r\n\t\t\t\tnewParentVNode._nextDom = oldDom;\r\n\t\t\t}\r\n\t\t} else if (\r\n\t\t\toldDom &&\r\n\t\t\toldVNode._dom == oldDom &&\r\n\t\t\toldDom.parentNode != parentDom\r\n\t\t) {\r\n\t\t\t// The above condition is to handle null placeholders. See test in placeholder.test.js:\r\n\t\t\t// `efficiently replace null placeholders in parent rerenders`\r\n\t\t\toldDom = getDomSibling(oldVNode);\r\n\t\t}\r\n\t}\r\n\r\n\tnewParentVNode._dom = firstChildDom;\r\n\r\n\t// Remove remaining oldChildren if there are any.\r\n\tfor (i = oldChildrenLength; i--; ) {\r\n\t\tif (oldChildren[i] != null) {\r\n\t\t\tif (\r\n\t\t\t\ttypeof newParentVNode.type == 'function' &&\r\n\t\t\t\toldChildren[i]._dom != null &&\r\n\t\t\t\toldChildren[i]._dom == newParentVNode._nextDom\r\n\t\t\t) {\r\n\t\t\t\t// If the newParentVNode.__nextDom points to a dom node that is about to\r\n\t\t\t\t// be unmounted, then get the next sibling of that vnode and set\r\n\t\t\t\t// _nextDom to it\r\n\t\t\t\tnewParentVNode._nextDom = getDomSibling(oldParentVNode, i + 1);\r\n\t\t\t}\r\n\r\n\t\t\tunmount(oldChildren[i], oldChildren[i]);\r\n\t\t}\r\n\t}\r\n\r\n\t// Set refs only after unmount\r\n\tif (refs) {\r\n\t\tfor (i = 0; i < refs.length; i++) {\r\n\t\t\tapplyRef(refs[i], refs[++i], refs[++i]);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction reorderChildren(childVNode, oldDom, parentDom) {\r\n\t// Note: VNodes in nested suspended trees may be missing _children.\r\n\tlet c = childVNode._children;\r\n\tlet tmp = 0;\r\n\tfor (; c && tmp < c.length; tmp++) {\r\n\t\tlet vnode = c[tmp];\r\n\t\tif (vnode) {\r\n\t\t\t// We typically enter this code path on sCU bailout, where we copy\r\n\t\t\t// oldVNode._children to newVNode._children. If that is the case, we need\r\n\t\t\t// to update the old children's _parent pointer to point to the newVNode\r\n\t\t\t// (childVNode here).\r\n\t\t\tvnode._parent = childVNode;\r\n\r\n\t\t\tif (typeof vnode.type == 'function') {\r\n\t\t\t\toldDom = reorderChildren(vnode, oldDom, parentDom);\r\n\t\t\t} else {\r\n\t\t\t\toldDom = placeChild(\r\n\t\t\t\t\tparentDom,\r\n\t\t\t\t\tvnode,\r\n\t\t\t\t\tvnode,\r\n\t\t\t\t\tc,\r\n\t\t\t\t\tvnode._dom,\r\n\t\t\t\t\toldDom\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn oldDom;\r\n}\r\n\r\n/**\r\n * Flatten and loop through the children of a virtual node\r\n * @param {import('../index').ComponentChildren} children The unflattened\r\n * children of a virtual node\r\n * @returns {import('../internal').VNode[]}\r\n */\r\nexport function toChildArray(children, out) {\r\n\tout = out || [];\r\n\tif (children == null || typeof children == 'boolean') {\r\n\t} else if (Array.isArray(children)) {\r\n\t\tchildren.some(child => {\r\n\t\t\ttoChildArray(child, out);\r\n\t\t});\r\n\t} else {\r\n\t\tout.push(children);\r\n\t}\r\n\treturn out;\r\n}\r\n\r\nfunction placeChild(\r\n\tparentDom,\r\n\tchildVNode,\r\n\toldVNode,\r\n\toldChildren,\r\n\tnewDom,\r\n\toldDom\r\n) {\r\n\tlet nextDom;\r\n\tif (childVNode._nextDom !== undefined) {\r\n\t\t// Only Fragments or components that return Fragment like VNodes will\r\n\t\t// have a non-undefined _nextDom. Continue the diff from the sibling\r\n\t\t// of last DOM child of this child VNode\r\n\t\tnextDom = childVNode._nextDom;\r\n\r\n\t\t// Eagerly cleanup _nextDom. We don't need to persist the value because\r\n\t\t// it is only used by `diffChildren` to determine where to resume the diff after\r\n\t\t// diffing Components and Fragments. Once we store it the nextDOM local var, we\r\n\t\t// can clean up the property\r\n\t\tchildVNode._nextDom = undefined;\r\n\t} else if (\r\n\t\toldVNode == null ||\r\n\t\tnewDom != oldDom ||\r\n\t\tnewDom.parentNode == null\r\n\t) {\r\n\t\touter: if (oldDom == null || oldDom.parentNode !== parentDom) {\r\n\t\t\tparentDom.appendChild(newDom);\r\n\t\t\tnextDom = null;\r\n\t\t} else {\r\n\t\t\t// `j<oldChildrenLength; j+=2` is an alternative to `j++<oldChildrenLength/2`\r\n\t\t\tfor (\r\n\t\t\t\tlet sibDom = oldDom, j = 0;\r\n\t\t\t\t(sibDom = sibDom.nextSibling) && j < oldChildren.length;\r\n\t\t\t\tj += 2\r\n\t\t\t) {\r\n\t\t\t\tif (sibDom == newDom) {\r\n\t\t\t\t\tbreak outer;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tparentDom.insertBefore(newDom, oldDom);\r\n\t\t\tnextDom = oldDom;\r\n\t\t}\r\n\t}\r\n\r\n\t// If we have pre-calculated the nextDOM node, use it. Else calculate it now\r\n\t// Strictly check for `undefined` here cuz `null` is a valid value of `nextDom`.\r\n\t// See more detail in create-element.js:createVNode\r\n\tif (nextDom !== undefined) {\r\n\t\toldDom = nextDom;\r\n\t} else {\r\n\t\toldDom = newDom.nextSibling;\r\n\t}\r\n\r\n\treturn oldDom;\r\n}\r\n","import { IS_NON_DIMENSIONAL } from '../constants';\r\nimport options from '../options';\r\n\r\n/**\r\n * Diff the old and new properties of a VNode and apply changes to the DOM node\r\n * @param {import('../internal').PreactElement} dom The DOM node to apply\r\n * changes to\r\n * @param {object} newProps The new props\r\n * @param {object} oldProps The old props\r\n * @param {boolean} isSvg Whether or not this node is an SVG node\r\n * @param {boolean} hydrate Whether or not we are in hydration mode\r\n */\r\nexport function diffProps(dom, newProps, oldProps, isSvg, hydrate) {\r\n\tlet i;\r\n\r\n\tfor (i in oldProps) {\r\n\t\tif (i !== 'children' && i !== 'key' && !(i in newProps)) {\r\n\t\t\tsetProperty(dom, i, null, oldProps[i], isSvg);\r\n\t\t}\r\n\t}\r\n\r\n\tfor (i in newProps) {\r\n\t\tif (\r\n\t\t\t(!hydrate || typeof newProps[i] == 'function') &&\r\n\t\t\ti !== 'children' &&\r\n\t\t\ti !== 'key' &&\r\n\t\t\ti !== 'value' &&\r\n\t\t\ti !== 'checked' &&\r\n\t\t\toldProps[i] !== newProps[i]\r\n\t\t) {\r\n\t\t\tsetProperty(dom, i, newProps[i], oldProps[i], isSvg);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction setStyle(style, key, value) {\r\n\tif (key[0] === '-') {\r\n\t\tstyle.setProperty(key, value);\r\n\t} else if (value == null) {\r\n\t\tstyle[key] = '';\r\n\t} else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {\r\n\t\tstyle[key] = value;\r\n\t} else {\r\n\t\tstyle[key] = value + 'px';\r\n\t}\r\n}\r\n\r\n/**\r\n * Set a property value on a DOM node\r\n * @param {import('../internal').PreactElement} dom The DOM node to modify\r\n * @param {string} name The name of the property to set\r\n * @param {*} value The value to set the property to\r\n * @param {*} oldValue The old value the property had\r\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node or not\r\n */\r\nexport function setProperty(dom, name, value, oldValue, isSvg) {\r\n\tlet useCapture;\r\n\r\n\to: if (name === 'style') {\r\n\t\tif (typeof value == 'string') {\r\n\t\t\tdom.style.cssText = value;\r\n\t\t} else {\r\n\t\t\tif (typeof oldValue == 'string') {\r\n\t\t\t\tdom.style.cssText = oldValue = '';\r\n\t\t\t}\r\n\r\n\t\t\tif (oldValue) {\r\n\t\t\t\tfor (name in oldValue) {\r\n\t\t\t\t\tif (!(value && name in value)) {\r\n\t\t\t\t\t\tsetStyle(dom.style, name, '');\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (value) {\r\n\t\t\t\tfor (name in value) {\r\n\t\t\t\t\tif (!oldValue || value[name] !== oldValue[name]) {\r\n\t\t\t\t\t\tsetStyle(dom.style, name, value[name]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\r\n\telse if (name[0] === 'o' && name[1] === 'n') {\r\n\t\tuseCapture = name !== (name = name.replace(/Capture$/, ''));\r\n\r\n\t\t// Infer correct casing for DOM built-in events:\r\n\t\tif (name.toLowerCase() in dom) name = name.toLowerCase().slice(2);\r\n\t\telse name = name.slice(2);\r\n\r\n\t\tif (!dom._listeners) dom._listeners = {};\r\n\t\tdom._listeners[name + useCapture] = value;\r\n\r\n\t\tif (value) {\r\n\t\t\tif (!oldValue) {\r\n\t\t\t\tconst handler = useCapture ? eventProxyCapture : eventProxy;\r\n\t\t\t\tdom.addEventListener(name, handler, useCapture);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tconst handler = useCapture ? eventProxyCapture : eventProxy;\r\n\t\t\tdom.removeEventListener(name, handler, useCapture);\r\n\t\t}\r\n\t} else if (name !== 'dangerouslySetInnerHTML') {\r\n\t\tif (isSvg) {\r\n\t\t\t// Normalize incorrect prop usage for SVG:\r\n\t\t\t// - xlink:href / xlinkHref --> href (xlink:href was removed from SVG and isn't needed)\r\n\t\t\t// - className --> class\r\n\t\t\tname = name.replace(/xlink[H:h]/, 'h').replace(/sName$/, 's');\r\n\t\t} else if (\r\n\t\t\tname !== 'href' &&\r\n\t\t\tname !== 'list' &&\r\n\t\t\tname !== 'form' &&\r\n\t\t\t// Default value in browsers is `-1` and an empty string is\r\n\t\t\t// cast to `0` instead\r\n\t\t\tname !== 'tabIndex' &&\r\n\t\t\tname !== 'download' &&\r\n\t\t\tname in dom\r\n\t\t) {\r\n\t\t\ttry {\r\n\t\t\t\tdom[name] = value == null ? '' : value;\r\n\t\t\t\t// labelled break is 1b smaller here than a return statement (sorry)\r\n\t\t\t\tbreak o;\r\n\t\t\t} catch (e) {}\r\n\t\t}\r\n\r\n\t\t// ARIA-attributes have a different notion of boolean values.\r\n\t\t// The value `false` is different from the attribute not\r\n\t\t// existing on the DOM, so we can't remove it. For non-boolean\r\n\t\t// ARIA-attributes we could treat false as a removal, but the\r\n\t\t// amount of exceptions would cost us too many bytes. On top of\r\n\t\t// that other VDOM frameworks also always stringify `false`.\r\n\r\n\t\tif (typeof value === 'function') {\r\n\t\t\t// never serialize functions as attribute values\r\n\t\t} else if (\r\n\t\t\tvalue != null &&\r\n\t\t\t(value !== false || (name[0] === 'a' && name[1] === 'r'))\r\n\t\t) {\r\n\t\t\tdom.setAttribute(name, value);\r\n\t\t} else {\r\n\t\t\tdom.removeAttribute(name);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Proxy an event to hooked event handlers\r\n * @param {Event} e The event object from the browser\r\n * @private\r\n */\r\nfunction eventProxy(e) {\r\n\tthis._listeners[e.type + false](options.event ? options.event(e) : e);\r\n}\r\n\r\nfunction eventProxyCapture(e) {\r\n\tthis._listeners[e.type + true](options.event ? options.event(e) : e);\r\n}\r\n","import { EMPTY_OBJ } from '../constants';\r\nimport { Component, getDomSibling } from '../component';\r\nimport { Fragment } from '../create-element';\r\nimport { diffChildren } from './children';\r\nimport { diffProps, setProperty } from './props';\r\nimport { assign, removeNode, slice } from '../util';\r\nimport options from '../options';\r\n\r\n/**\r\n * Diff two virtual nodes and apply proper changes to the DOM\r\n * @param {import('../internal').PreactElement} parentDom The parent of the DOM element\r\n * @param {import('../internal').VNode} newVNode The new virtual node\r\n * @param {import('../internal').VNode} oldVNode The old virtual node\r\n * @param {object} globalContext The current context object. Modified by getChildContext\r\n * @param {boolean} isSvg Whether or not this element is an SVG node\r\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\r\n * @param {Array<import('../internal').Component>} commitQueue List of components\r\n * which have callbacks to invoke in commitRoot\r\n * @param {import('../internal').PreactElement} oldDom The current attached DOM\r\n * element any new dom elements should be placed around. Likely `null` on first\r\n * render (except when hydrating). Can be a sibling DOM element when diffing\r\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\r\n * @param {boolean} [isHydrating] Whether or not we are in hydration\r\n */\r\nexport function diff(\r\n\tparentDom,\r\n\tnewVNode,\r\n\toldVNode,\r\n\tglobalContext,\r\n\tisSvg,\r\n\texcessDomChildren,\r\n\tcommitQueue,\r\n\toldDom,\r\n\tisHydrating\r\n) {\r\n\tlet tmp,\r\n\t\tnewType = newVNode.type;\r\n\r\n\t// When passing through createElement it assigns the object\r\n\t// constructor as undefined. This to prevent JSON-injection.\r\n\tif (newVNode.constructor !== undefined) return null;\r\n\r\n\t// If the previous diff bailed out, resume creating/hydrating.\r\n\tif (oldVNode._hydrating != null) {\r\n\t\tisHydrating = oldVNode._hydrating;\r\n\t\toldDom = newVNode._dom = oldVNode._dom;\r\n\t\t// if we resume, we want the tree to be \"unlocked\"\r\n\t\tnewVNode._hydrating = null;\r\n\t\texcessDomChildren = [oldDom];\r\n\t}\r\n\r\n\tif ((tmp = options._diff)) tmp(newVNode);\r\n\r\n\ttry {\r\n\t\touter: if (typeof newType == 'function') {\r\n\t\t\tlet c, isNew, oldProps, oldState, snapshot, clearProcessingException;\r\n\t\t\tlet newProps = newVNode.props;\r\n\r\n\t\t\t// Necessary for createContext api. Setting this property will pass\r\n\t\t\t// the context value as `this.context` just for this component.\r\n\t\t\ttmp = newType.contextType;\r\n\t\t\tlet provider = tmp && globalContext[tmp._id];\r\n\t\t\tlet componentContext = tmp\r\n\t\t\t\t? provider\r\n\t\t\t\t\t? provider.props.value\r\n\t\t\t\t\t: tmp._defaultValue\r\n\t\t\t\t: globalContext;\r\n\r\n\t\t\t// Get component and set it to `c`\r\n\t\t\tif (oldVNode._component) {\r\n\t\t\t\tc = newVNode._component = oldVNode._component;\r\n\t\t\t\tclearProcessingException = c._processingException = c._pendingError;\r\n\t\t\t} else {\r\n\t\t\t\t// Instantiate the new component\r\n\t\t\t\tif ('prototype' in newType && newType.prototype.render) {\r\n\t\t\t\t\t// @ts-ignore The check above verifies that newType is suppose to be constructed\r\n\t\t\t\t\tnewVNode._component = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// @ts-ignore Trust me, Component implements the interface we want\r\n\t\t\t\t\tnewVNode._component = c = new Component(newProps, componentContext);\r\n\t\t\t\t\tc.constructor = newType;\r\n\t\t\t\t\tc.render = doRender;\r\n\t\t\t\t}\r\n\t\t\t\tif (provider) provider.sub(c);\r\n\r\n\t\t\t\tc.props = newProps;\r\n\t\t\t\tif (!c.state) c.state = {};\r\n\t\t\t\tc.context = componentContext;\r\n\t\t\t\tc._globalContext = globalContext;\r\n\t\t\t\tisNew = c._dirty = true;\r\n\t\t\t\tc._renderCallbacks = [];\r\n\t\t\t}\r\n\r\n\t\t\t// Invoke getDerivedStateFromProps\r\n\t\t\tif (c._nextState == null) {\r\n\t\t\t\tc._nextState = c.state;\r\n\t\t\t}\r\n\t\t\tif (newType.getDerivedStateFromProps != null) {\r\n\t\t\t\tif (c._nextState == c.state) {\r\n\t\t\t\t\tc._nextState = assign({}, c._nextState);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tassign(\r\n\t\t\t\t\tc._nextState,\r\n\t\t\t\t\tnewType.getDerivedStateFromProps(newProps, c._nextState)\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\toldProps = c.props;\r\n\t\t\toldState = c.state;\r\n\r\n\t\t\t// Invoke pre-render lifecycle methods\r\n\t\t\tif (isNew) {\r\n\t\t\t\tif (\r\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\r\n\t\t\t\t\tc.componentWillMount != null\r\n\t\t\t\t) {\r\n\t\t\t\t\tc.componentWillMount();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (c.componentDidMount != null) {\r\n\t\t\t\t\tc._renderCallbacks.push(c.componentDidMount);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (\r\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\r\n\t\t\t\t\tnewProps !== oldProps &&\r\n\t\t\t\t\tc.componentWillReceiveProps != null\r\n\t\t\t\t) {\r\n\t\t\t\t\tc.componentWillReceiveProps(newProps, componentContext);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (\r\n\t\t\t\t\t(!c._force &&\r\n\t\t\t\t\t\tc.shouldComponentUpdate != null &&\r\n\t\t\t\t\t\tc.shouldComponentUpdate(\r\n\t\t\t\t\t\t\tnewProps,\r\n\t\t\t\t\t\t\tc._nextState,\r\n\t\t\t\t\t\t\tcomponentContext\r\n\t\t\t\t\t\t) === false) ||\r\n\t\t\t\t\tnewVNode._original === oldVNode._original\r\n\t\t\t\t) {\r\n\t\t\t\t\tc.props = newProps;\r\n\t\t\t\t\tc.state = c._nextState;\r\n\t\t\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\r\n\t\t\t\t\tif (newVNode._original !== oldVNode._original) c._dirty = false;\r\n\t\t\t\t\tc._vnode = newVNode;\r\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\r\n\t\t\t\t\tnewVNode._children = oldVNode._children;\r\n\t\t\t\t\tnewVNode._children.forEach(vnode => {\r\n\t\t\t\t\t\tif (vnode) vnode._parent = newVNode;\r\n\t\t\t\t\t});\r\n\t\t\t\t\tif (c._renderCallbacks.length) {\r\n\t\t\t\t\t\tcommitQueue.push(c);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak outer;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (c.componentWillUpdate != null) {\r\n\t\t\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (c.componentDidUpdate != null) {\r\n\t\t\t\t\tc._renderCallbacks.push(() => {\r\n\t\t\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tc.context = componentContext;\r\n\t\t\tc.props = newProps;\r\n\t\t\tc.state = c._nextState;\r\n\r\n\t\t\tif ((tmp = options._render)) tmp(newVNode);\r\n\r\n\t\t\tc._dirty = false;\r\n\t\t\tc._vnode = newVNode;\r\n\t\t\tc._parentDom = parentDom;\r\n\r\n\t\t\ttmp = c.render(c.props, c.state, c.context);\r\n\r\n\t\t\t// Handle setState called in render, see #2553\r\n\t\t\tc.state = c._nextState;\r\n\r\n\t\t\tif (c.getChildContext != null) {\r\n\t\t\t\tglobalContext = assign(assign({}, globalContext), c.getChildContext());\r\n\t\t\t}\r\n\r\n\t\t\tif (!isNew && c.getSnapshotBeforeUpdate != null) {\r\n\t\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\r\n\t\t\t}\r\n\r\n\t\t\tlet isTopLevelFragment =\r\n\t\t\t\ttmp != null && tmp.type === Fragment && tmp.key == null;\r\n\t\t\tlet renderResult = isTopLevelFragment ? tmp.props.children : tmp;\r\n\r\n\t\t\tdiffChildren(\r\n\t\t\t\tparentDom,\r\n\t\t\t\tArray.isArray(renderResult) ? renderResult : [renderResult],\r\n\t\t\t\tnewVNode,\r\n\t\t\t\toldVNode,\r\n\t\t\t\tglobalContext,\r\n\t\t\t\tisSvg,\r\n\t\t\t\texcessDomChildren,\r\n\t\t\t\tcommitQueue,\r\n\t\t\t\toldDom,\r\n\t\t\t\tisHydrating\r\n\t\t\t);\r\n\r\n\t\t\tc.base = newVNode._dom;\r\n\r\n\t\t\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\r\n\t\t\tnewVNode._hydrating = null;\r\n\r\n\t\t\tif (c._renderCallbacks.length) {\r\n\t\t\t\tcommitQueue.push(c);\r\n\t\t\t}\r\n\r\n\t\t\tif (clearProcessingException) {\r\n\t\t\t\tc._pendingError = c._processingException = null;\r\n\t\t\t}\r\n\r\n\t\t\tc._force = false;\r\n\t\t} else if (\r\n\t\t\texcessDomChildren == null &&\r\n\t\t\tnewVNode._original === oldVNode._original\r\n\t\t) {\r\n\t\t\tnewVNode._children = oldVNode._children;\r\n\t\t\tnewVNode._dom = oldVNode._dom;\r\n\t\t} else {\r\n\t\t\tnewVNode._dom = diffElementNodes(\r\n\t\t\t\toldVNode._dom,\r\n\t\t\t\tnewVNode,\r\n\t\t\t\toldVNode,\r\n\t\t\t\tglobalContext,\r\n\t\t\t\tisSvg,\r\n\t\t\t\texcessDomChildren,\r\n\t\t\t\tcommitQueue,\r\n\t\t\t\tisHydrating\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tif ((tmp = options.diffed)) tmp(newVNode);\r\n\t} catch (e) {\r\n\t\tnewVNode._original = null;\r\n\t\t// if hydrating or creating initial tree, bailout preserves DOM:\r\n\t\tif (isHydrating || excessDomChildren != null) {\r\n\t\t\tnewVNode._dom = oldDom;\r\n\t\t\tnewVNode._hydrating = !!isHydrating;\r\n\t\t\texcessDomChildren[excessDomChildren.indexOf(oldDom)] = null;\r\n\t\t\t// ^ could possibly be simplified to:\r\n\t\t\t// excessDomChildren.length = 0;\r\n\t\t}\r\n\t\toptions._catchError(e, newVNode, oldVNode);\r\n\t}\r\n}\r\n\r\n/**\r\n * @param {Array<import('../internal').Component>} commitQueue List of components\r\n * which have callbacks to invoke in commitRoot\r\n * @param {import('../internal').VNode} root\r\n */\r\nexport function commitRoot(commitQueue, root) {\r\n\tif (options._commit) options._commit(root, commitQueue);\r\n\r\n\tcommitQueue.some(c => {\r\n\t\ttry {\r\n\t\t\t// @ts-ignore Reuse the commitQueue variable here so the type changes\r\n\t\t\tcommitQueue = c._renderCallbacks;\r\n\t\t\tc._renderCallbacks = [];\r\n\t\t\tcommitQueue.some(cb => {\r\n\t\t\t\t// @ts-ignore See above ts-ignore on commitQueue\r\n\t\t\t\tcb.call(c);\r\n\t\t\t});\r\n\t\t} catch (e) {\r\n\t\t\toptions._catchError(e, c._vnode);\r\n\t\t}\r\n\t});\r\n}\r\n\r\n/**\r\n * Diff two virtual nodes representing DOM element\r\n * @param {import('../internal').PreactElement} dom The DOM element representing\r\n * the virtual nodes being diffed\r\n * @param {import('../internal').VNode} newVNode The new virtual node\r\n * @param {import('../internal').VNode} oldVNode The old virtual node\r\n * @param {object} globalContext The current context object\r\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\r\n * @param {*} excessDomChildren\r\n * @param {Array<import('../internal').Component>} commitQueue List of components\r\n * which have callbacks to invoke in commitRoot\r\n * @param {boolean} isHydrating Whether or not we are in hydration\r\n * @returns {import('../internal').PreactElement}\r\n */\r\nfunction diffElementNodes(\r\n\tdom,\r\n\tnewVNode,\r\n\toldVNode,\r\n\tglobalContext,\r\n\tisSvg,\r\n\texcessDomChildren,\r\n\tcommitQueue,\r\n\tisHydrating\r\n) {\r\n\tlet oldProps = oldVNode.props;\r\n\tlet newProps = newVNode.props;\r\n\tlet nodeType = newVNode.type;\r\n\tlet i = 0;\r\n\r\n\t// Tracks entering and exiting SVG namespace when descending through the tree.\r\n\tif (nodeType === 'svg') isSvg = true;\r\n\r\n\tif (excessDomChildren != null) {\r\n\t\tfor (; i < excessDomChildren.length; i++) {\r\n\t\t\tconst child = excessDomChildren[i];\r\n\r\n\t\t\t// if newVNode matches an element in excessDomChildren or the `dom`\r\n\t\t\t// argument matches an element in excessDomChildren, remove it from\r\n\t\t\t// excessDomChildren so it isn't later removed in diffChildren\r\n\t\t\tif (\r\n\t\t\t\tchild &&\r\n\t\t\t\t'setAttribute' in child === !!nodeType &&\r\n\t\t\t\t(nodeType ? child.localName === nodeType : child.nodeType === 3)\r\n\t\t\t) {\r\n\t\t\t\tdom = child;\r\n\t\t\t\texcessDomChildren[i] = null;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (dom == null) {\r\n\t\tif (nodeType === null) {\r\n\t\t\t// @ts-ignore createTextNode returns Text, we expect PreactElement\r\n\t\t\treturn document.createTextNode(newProps);\r\n\t\t}\r\n\r\n\t\tif (isSvg) {\r\n\t\t\tdom = document.createElementNS(\r\n\t\t\t\t'http://www.w3.org/2000/svg',\r\n\t\t\t\t// @ts-ignore We know `newVNode.type` is a string\r\n\t\t\t\tnodeType\r\n\t\t\t);\r\n\t\t} else {\r\n\t\t\tdom = document.createElement(\r\n\t\t\t\t// @ts-ignore We know `newVNode.type` is a string\r\n\t\t\t\tnodeType,\r\n\t\t\t\tnewProps.is && newProps\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// we created a new parent, so none of the previously attached children can be reused:\r\n\t\texcessDomChildren = null;\r\n\t\t// we are creating a new node, so we can assume this is a new subtree (in case we are hydrating), this deopts the hydrate\r\n\t\tisHydrating = false;\r\n\t}\r\n\r\n\tif (nodeType === null) {\r\n\t\t// During hydration, we still have to split merged text from SSR'd HTML.\r\n\t\tif (oldProps !== newProps && (!isHydrating || dom.data !== newProps)) {\r\n\t\t\tdom.data = newProps;\r\n\t\t}\r\n\t} else {\r\n\t\t// If excessDomChildren was not null, repopulate it with the current element's children:\r\n\t\texcessDomChildren = excessDomChildren && slice.call(dom.childNodes);\r\n\r\n\t\toldProps = oldVNode.props || EMPTY_OBJ;\r\n\r\n\t\tlet oldHtml = oldProps.dangerouslySetInnerHTML;\r\n\t\tlet newHtml = newProps.dangerouslySetInnerHTML;\r\n\r\n\t\t// During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\r\n\t\t// @TODO we should warn in debug mode when props don't match here.\r\n\t\tif (!isHydrating) {\r\n\t\t\t// But, if we are in a situation where we are using existing DOM (e.g. replaceNode)\r\n\t\t\t// we should read the existing DOM attributes to diff them\r\n\t\t\tif (excessDomChildren != null) {\r\n\t\t\t\toldProps = {};\r\n\t\t\t\tfor (i = 0; i < dom.attributes.length; i++) {\r\n\t\t\t\t\toldProps[dom.attributes[i].name] = dom.attributes[i].value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (newHtml || oldHtml) {\r\n\t\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\r\n\t\t\t\tif (\r\n\t\t\t\t\t!newHtml ||\r\n\t\t\t\t\t((!oldHtml || newHtml.__html != oldHtml.__html) &&\r\n\t\t\t\t\t\tnewHtml.__html !== dom.innerHTML)\r\n\t\t\t\t) {\r\n\t\t\t\t\tdom.innerHTML = (newHtml && newHtml.__html) || '';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tdiffProps(dom, newProps, oldProps, isSvg, isHydrating);\r\n\r\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\r\n\t\tif (newHtml) {\r\n\t\t\tnewVNode._children = [];\r\n\t\t} else {\r\n\t\t\ti = newVNode.props.children;\r\n\t\t\tdiffChildren(\r\n\t\t\t\tdom,\r\n\t\t\t\tArray.isArray(i) ? i : [i],\r\n\t\t\t\tnewVNode,\r\n\t\t\t\toldVNode,\r\n\t\t\t\tglobalContext,\r\n\t\t\t\tisSvg && nodeType !== 'foreignObject',\r\n\t\t\t\texcessDomChildren,\r\n\t\t\t\tcommitQueue,\r\n\t\t\t\texcessDomChildren\r\n\t\t\t\t\t? excessDomChildren[0]\r\n\t\t\t\t\t: oldVNode._children && getDomSibling(oldVNode, 0),\r\n\t\t\t\tisHydrating\r\n\t\t\t);\r\n\r\n\t\t\t// Remove children that are not part of any vnode.\r\n\t\t\tif (excessDomChildren != null) {\r\n\t\t\t\tfor (i = excessDomChildren.length; i--; ) {\r\n\t\t\t\t\tif (excessDomChildren[i] != null) removeNode(excessDomChildren[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// (as above, don't diff props during hydration)\r\n\t\tif (!isHydrating) {\r\n\t\t\tif (\r\n\t\t\t\t'value' in newProps &&\r\n\t\t\t\t(i = newProps.value) !== undefined &&\r\n\t\t\t\t// #2756 For the <progress>-element the initial value is 0,\r\n\t\t\t\t// despite the attribute not being present. When the attribute\r\n\t\t\t\t// is missing the progress bar is treated as indeterminate.\r\n\t\t\t\t// To fix that we'll always update it when it is 0 for progress elements\r\n\t\t\t\t(i !== oldProps.value ||\r\n\t\t\t\t\ti !== dom.value ||\r\n\t\t\t\t\t(nodeType === 'progress' && !i))\r\n\t\t\t) {\r\n\t\t\t\tsetProperty(dom, 'value', i, oldProps.value, false);\r\n\t\t\t}\r\n\t\t\tif (\r\n\t\t\t\t'checked' in newProps &&\r\n\t\t\t\t(i = newProps.checked) !== undefined &&\r\n\t\t\t\ti !== dom.checked\r\n\t\t\t) {\r\n\t\t\t\tsetProperty(dom, 'checked', i, oldProps.checked, false);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn dom;\r\n}\r\n\r\n/**\r\n * Invoke or update a ref, depending on whether it is a function or object ref.\r\n * @param {object|function} ref\r\n * @param {any} value\r\n * @param {import('../internal').VNode} vnode\r\n */\r\nexport function applyRef(ref, value, vnode) {\r\n\ttry {\r\n\t\tif (typeof ref == 'function') ref(value);\r\n\t\telse ref.current = value;\r\n\t} catch (e) {\r\n\t\toptions._catchError(e, vnode);\r\n\t}\r\n}\r\n\r\n/**\r\n * Unmount a virtual node from the tree and apply DOM changes\r\n * @param {import('../internal').VNode} vnode The virtual node to unmount\r\n * @param {import('../internal').VNode} parentVNode The parent of the VNode that\r\n * initiated the unmount\r\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\r\n * current element is already detached from the DOM.\r\n */\r\nexport function unmount(vnode, parentVNode, skipRemove) {\r\n\tlet r;\r\n\tif (options.unmount) options.unmount(vnode);\r\n\r\n\tif ((r = vnode.ref)) {\r\n\t\tif (!r.current || r.current === vnode._dom) applyRef(r, null, parentVNode);\r\n\t}\r\n\r\n\tif ((r = vnode._component) != null) {\r\n\t\tif (r.componentWillUnmount) {\r\n\t\t\ttry {\r\n\t\t\t\tr.componentWillUnmount();\r\n\t\t\t} catch (e) {\r\n\t\t\t\toptions._catchError(e, parentVNode);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tr.base = r._parentDom = null;\r\n\t}\r\n\r\n\tif ((r = vnode._children)) {\r\n\t\tfor (let i = 0; i < r.length; i++) {\r\n\t\t\tif (r[i]) {\r\n\t\t\t\tunmount(r[i], parentVNode, typeof vnode.type != 'function');\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (!skipRemove && vnode._dom != null) removeNode(vnode._dom);\r\n\r\n\t// Must be set to `undefined` to properly clean up `_nextDom`\r\n\t// for which `null` is a valid value. See comment in `create-element.js`\r\n\tvnode._dom = vnode._nextDom = undefined;\r\n}\r\n\r\n/** The `.render()` method for a PFC backing instance. */\r\nfunction doRender(props, state, context) {\r\n\treturn this.constructor(props, context);\r\n}\r\n","import { EMPTY_OBJ } from './constants';\r\nimport { commitRoot, diff } from './diff/index';\r\nimport { createElement, Fragment } from './create-element';\r\nimport options from './options';\r\nimport { slice } from './util';\r\n\r\n/**\r\n * Render a Preact virtual node into a DOM element\r\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\r\n * @param {import('./internal').PreactElement} parentDom The DOM element to\r\n * render into\r\n * @param {import('./internal').PreactElement | object} [replaceNode] Optional: Attempt to re-use an\r\n * existing DOM tree rooted at `replaceNode`\r\n */\r\nexport function render(vnode, parentDom, replaceNode) {\r\n\tif (options._root) options._root(vnode, parentDom);\r\n\r\n\t// We abuse the `replaceNode` parameter in `hydrate()` to signal if we are in\r\n\t// hydration mode or not by passing the `hydrate` function instead of a DOM\r\n\t// element..\r\n\tlet isHydrating = typeof replaceNode === 'function';\r\n\r\n\t// To be able to support calling `render()` multiple times on the same\r\n\t// DOM node, we need to obtain a reference to the previous tree. We do\r\n\t// this by assigning a new `_children` property to DOM nodes which points\r\n\t// to the last rendered tree. By default this property is not present, which\r\n\t// means that we are mounting a new tree for the first time.\r\n\tlet oldVNode = isHydrating\r\n\t\t? null\r\n\t\t: (replaceNode && replaceNode._children) || parentDom._children;\r\n\r\n\tvnode = (\r\n\t\t(!isHydrating && replaceNode) ||\r\n\t\tparentDom\r\n\t)._children = createElement(Fragment, null, [vnode]);\r\n\r\n\t// List of effects that need to be called after diffing.\r\n\tlet commitQueue = [];\r\n\tdiff(\r\n\t\tparentDom,\r\n\t\t// Determine the new vnode tree and store it on the DOM element on\r\n\t\t// our custom `_children` property.\r\n\t\tvnode,\r\n\t\toldVNode || EMPTY_OBJ,\r\n\t\tEMPTY_OBJ,\r\n\t\tparentDom.ownerSVGElement !== undefined,\r\n\t\t!isHydrating && replaceNode\r\n\t\t\t? [replaceNode]\r\n\t\t\t: oldVNode\r\n\t\t\t? null\r\n\t\t\t: parentDom.firstChild\r\n\t\t\t? slice.call(parentDom.childNodes)\r\n\t\t\t: null,\r\n\t\tcommitQueue,\r\n\t\t!isHydrating && replaceNode\r\n\t\t\t? replaceNode\r\n\t\t\t: oldVNode\r\n\t\t\t? oldVNode._dom\r\n\t\t\t: parentDom.firstChild,\r\n\t\tisHydrating\r\n\t);\r\n\r\n\t// Flush all queued effects\r\n\tcommitRoot(commitQueue, vnode);\r\n}\r\n\r\n/**\r\n * Update an existing DOM element with data from a Preact virtual node\r\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\r\n * @param {import('./internal').PreactElement} parentDom The DOM element to\r\n * update\r\n */\r\nexport function hydrate(vnode, parentDom) {\r\n\trender(vnode, parentDom, hydrate);\r\n}\r\n","import { assign, slice } from './util';\r\nimport { createVNode } from './create-element';\r\n\r\n/**\r\n * Clones the given VNode, optionally adding attributes/props and replacing its children.\r\n * @param {import('./internal').VNode} vnode The virtual DOM element to clone\r\n * @param {object} props Attributes/props to add when cloning\r\n * @param {Array<import('./internal').ComponentChildren>} rest Any additional arguments will be used as replacement children.\r\n * @returns {import('./internal').VNode}\r\n */\r\nexport function cloneElement(vnode, props, children) {\r\n\tlet normalizedProps = assign({}, vnode.props),\r\n\t\tkey,\r\n\t\tref,\r\n\t\ti;\r\n\tfor (i in props) {\r\n\t\tif (i == 'key') key = props[i];\r\n\t\telse if (i == 'ref') ref = props[i];\r\n\t\telse normalizedProps[i] = props[i];\r\n\t}\r\n\r\n\tif (arguments.length > 2) {\r\n\t\tnormalizedProps.children =\r\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\r\n\t}\r\n\r\n\treturn createVNode(\r\n\t\tvnode.type,\r\n\t\tnormalizedProps,\r\n\t\tkey || vnode.key,\r\n\t\tref || vnode.ref,\r\n\t\tnull\r\n\t);\r\n}\r\n","/**\r\n * Find the closest error boundary to a thrown error and call it\r\n * @param {object} error The thrown value\r\n * @param {import('../internal').VNode} vnode The vnode that threw\r\n * the error that was caught (except for unmounting when this parameter\r\n * is the highest parent that was being unmounted)\r\n */\r\nexport function _catchError(error, vnode) {\r\n\t/** @type {import('../internal').Component} */\r\n\tlet component, ctor, handled;\r\n\r\n\tfor (; (vnode = vnode._parent); ) {\r\n\t\tif ((component = vnode._component) && !component._processingException) {\r\n\t\t\ttry {\r\n\t\t\t\tctor = component.constructor;\r\n\r\n\t\t\t\tif (ctor && ctor.getDerivedStateFromError != null) {\r\n\t\t\t\t\tcomponent.setState(ctor.getDerivedStateFromError(error));\r\n\t\t\t\t\thandled = component._dirty;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (component.componentDidCatch != null) {\r\n\t\t\t\t\tcomponent.componentDidCatch(error);\r\n\t\t\t\t\thandled = component._dirty;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// This is an error boundary. Mark it as having bailed out, and whether it was mid-hydration.\r\n\t\t\t\tif (handled) {\r\n\t\t\t\t\treturn (component._pendingError = component);\r\n\t\t\t\t}\r\n\t\t\t} catch (e) {\r\n\t\t\t\terror = e;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tthrow error;\r\n}\r\n","import { options, Fragment } from 'preact';\r\n\r\n/** @typedef {import('preact').VNode} VNode */\r\n\r\nlet vnodeId = 0;\r\n\r\n/**\r\n * @fileoverview\r\n * This file exports various methods that implement Babel's \"automatic\" JSX runtime API:\r\n * - jsx(type, props, key)\r\n * - jsxs(type, props, key)\r\n * - jsxDEV(type, props, key, __source, __self)\r\n *\r\n * The implementation of createVNode here is optimized for performance.\r\n * Benchmarks: https://esbench.com/bench/5f6b54a0b4632100a7dcd2b3\r\n */\r\n\r\n/**\r\n * JSX.Element factory used by Babel's {runtime:\"automatic\"} JSX transform\r\n * @param {VNode['type']} type\r\n * @param {VNode['props']} props\r\n * @param {VNode['key']} [key]\r\n * @param {string} [__source]\r\n * @param {string} [__self]\r\n */\r\nfunction createVNode(type, props, key, __source, __self) {\r\n\t// We'll want to preserve `ref` in props to get rid of the need for\r\n\t// forwardRef components in the future, but that should happen via\r\n\t// a separate PR.\r\n\tlet normalizedProps = {},\r\n\t\tref,\r\n\t\ti;\r\n\tfor (i in props) {\r\n\t\tif (i == 'ref') {\r\n\t\t\tref = props[i];\r\n\t\t} else {\r\n\t\t\tnormalizedProps[i] = props[i];\r\n\t\t}\r\n\t}\r\n\r\n\tconst vnode = {\r\n\t\ttype,\r\n\t\tprops: normalizedProps,\r\n\t\tkey,\r\n\t\tref,\r\n\t\t_children: null,\r\n\t\t_parent: null,\r\n\t\t_depth: 0,\r\n\t\t_dom: null,\r\n\t\t_nextDom: undefined,\r\n\t\t_component: null,\r\n\t\t_hydrating: null,\r\n\t\tconstructor: undefined,\r\n\t\t_original: --vnodeId,\r\n\t\t__source,\r\n\t\t__self\r\n\t};\r\n\r\n\t// If a Component VNode, check for and apply defaultProps.\r\n\t// Note: `type` is often a String, and can be `undefined` in development.\r\n\tif (typeof type === 'function' && (ref = type.defaultProps)) {\r\n\t\tfor (i in ref)\r\n\t\t\tif (typeof normalizedProps[i] === 'undefined') {\r\n\t\t\t\tnormalizedProps[i] = ref[i];\r\n\t\t\t}\r\n\t}\r\n\r\n\tif (options.vnode) options.vnode(vnode);\r\n\treturn vnode;\r\n}\r\n\r\nexport {\r\n\tcreateVNode as jsx,\r\n\tcreateVNode as jsxs,\r\n\tcreateVNode as jsxDEV,\r\n\tFragment\r\n};\r\n","/*!\n  Copyright (c) 2018 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames() {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tif (arg.length) {\n\t\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\t\tif (inner) {\n\t\t\t\t\t\tclasses.push(inner);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tif (arg.toString === Object.prototype.toString) {\n\t\t\t\t\tfor (var key in arg) {\n\t\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tclasses.push(arg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\tdefine('classnames', [], function () {\n\t\t\treturn classNames;\n\t\t});\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n","import classNames from 'classnames'\nimport {Fragment} from \"preact\";\nimport {MutableRef} from \"preact/hooks\";\n\nexport interface PaginationProps {\n  currentPage: number\n  totalPages: number\n  onPageChange: (pageNumber: number) => void\n  ref?: MutableRef<any>\n}\n\ninterface PageData {\n  number?: number\n  selected?: boolean\n  separator: boolean\n}\n\nconst PAGINATION_DELTA = 2\nconst MAX_PAGES = 5\n\nexport function StkPagination({ totalPages, currentPage, onPageChange }: PaginationProps) {\n  totalPages = totalPages || MAX_PAGES;\n\n  const buildPageNumber = (number: number): PageData => ({\n    number,\n    selected: number === currentPage,\n    separator: false,\n  })\n\n  const handlePageChange = (number: number) => {\n    onPageChange(number);\n  }\n\n  const generatePages = (): ReadonlyArray<PageData> => {\n    // Based on simple-pagination.js algorithm\n    // https://gist.github.com/kottenator/9d936eb3e4e3c3e02598\n    const last = totalPages\n    const left = currentPage - PAGINATION_DELTA\n    const right = currentPage + PAGINATION_DELTA + 1\n\n    const range = Array.from(new Array(last), (n, index) => index + 1).filter(\n      (page) => {\n        return page === 1 || page === last || (left <= page && page < right)\n      },\n    )\n\n    const results: PageData[] = []\n\n    let previousPage: number\n    range.forEach((page) => {\n      if (previousPage) {\n        if (page - previousPage === 2) {\n          results.push(buildPageNumber(previousPage + 1))\n        } else if (page - previousPage !== 1) {\n          results.push({ separator: true })\n        }\n      }\n      results.push(buildPageNumber(page))\n      previousPage = page\n    })\n\n    return results\n  }\n\n  const pages = generatePages()\n  const hasPreviousPage = 0 < currentPage - 1\n  const hasNextPage = currentPage + 1 <= totalPages\n\n  return (\n    <>\n      <nav className=\"stk-pagination\">\n        {hasPreviousPage ? (\n          <button\n            onClick={() => handlePageChange(currentPage - 1)}\n            className={classNames(\n              'stk-pagination__button',\n              'stk-pagination__button--prev',\n              'stk-pagination__button--first',\n            )}\n          >\n            Previous\n          </button>\n        ) : (\n          <span\n            className={classNames(\n              'stk-pagination__button',\n              'stk-pagination__button--prev',\n              'stk-pagination__button--first',\n              'stk-pagination__button--disabled',\n            )}\n          >\n            Previous\n          </span>\n        )}\n        {pages.map((page, index) => (\n          <Fragment key={page}>\n            {page.number ? (\n              <button\n                onClick={() => handlePageChange(page.number)}\n                className={classNames('stk-pagination__button', {\n                  'stk-pagination__button--selected': page.selected,\n                  'stk-pagination__button--first': isSeparatorPrior(\n                    page,\n                    pages,\n                  ),\n                  'stk-pagination__button--last': isSeparatorAfter(page, pages),\n                })}\n                key={index}\n              >\n                {page.number}\n              </button>\n            ) : (\n              <span className=\"stk-pagination__separator\">&hellip;</span>\n            )}\n          </Fragment>\n        ))}\n        {hasNextPage ? (\n          <button\n            onClick={() => handlePageChange(currentPage + 1)}\n            className={classNames(\n              'stk-pagination__button',\n              'stk-pagination__button--next',\n              'stk-pagination__button--last',\n            )}\n          >\n            Next\n          </button>\n        ) : (\n          <span\n            className={classNames(\n              'stk-pagination__button',\n              'stk-pagination__button--next',\n              'stk-pagination__button--last',\n              'stk-pagination__button--disabled',\n            )}\n          >\n            Next\n          </span>\n        )}\n      </nav>\n    </>\n  )\n}\n\nfunction isSeparatorPrior(\n  page: PageData,\n  pages: ReadonlyArray<PageData>,\n): boolean {\n  return pages[pages.indexOf(page) - 1]?.separator\n}\n\nfunction isSeparatorAfter(\n  page: PageData,\n  pages: ReadonlyArray<PageData>,\n): boolean {\n  return pages[pages.indexOf(page) + 1]?.separator\n}\n","import register from 'preact-custom-element';\nimport {useRef} from \"preact/hooks\"\nimport {StkPagination} from \"./pagination\";\nimport {VNode} from \"preact\";\n\nfunction StkPaginationWC({ currentPage, totalPages }): VNode {\n  const ref = useRef(null);\n\n  // Events\n  const pageChange = (pageNumber: number) => {\n    const componentElement = ref.current.base.parentElement;\n    componentElement.dispatchEvent(new CustomEvent('pageChange', {\n      detail: { pageNumber }\n    }));\n  };\n\n  return (\n    <StkPagination\n      ref={ref}\n      currentPage={parseNumberProp(currentPage)}\n      totalPages={parseNumberProp(totalPages)}\n      onPageChange={pageChange}\n    />\n  )\n}\n\nfunction parseNumberProp(prop: string | number): number {\n  return typeof prop === 'string' ? parseInt(prop, 10) : prop;\n}\n\nregister(StkPaginationWC, 'stk-pagination', ['current-page', 'total-pages', 'data'], { shadow: false });\n"]}